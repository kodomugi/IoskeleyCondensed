name: Build and Release Font

on:
  schedule:
    - cron: "0 4 * * *" # Daily at UTC 04:00 (Taiwan 12:00)
  workflow_dispatch:
    inputs:
      force_build:
        description: "Force build even if no new Iosevka release"
        required: false
        default: false
        type: boolean

jobs:
  check:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      iosevka_version: ${{ steps.check.outputs.iosevka_version }}
    steps:
      - name: Check for new Iosevka release
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IOSEVKA_VERSION=$(gh api repos/be5invis/Iosevka/releases/latest --jq '.tag_name')
          echo "Latest Iosevka version: $IOSEVKA_VERSION"
          echo "iosevka_version=$IOSEVKA_VERSION" >> $GITHUB_OUTPUT

          if [ "${{ inputs.force_build }}" = "true" ]; then
            echo "Force build requested"
            echo "should_build=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get our latest release tag (may not exist yet)
          OUR_LATEST=$(gh api repos/${{ github.repository }}/releases/latest --jq '.tag_name' 2>/dev/null || echo "")
          echo "Our latest release: $OUR_LATEST"

          if echo "$OUR_LATEST" | grep -qF "$IOSEVKA_VERSION"; then
            echo "Already built for Iosevka $IOSEVKA_VERSION"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "New Iosevka version detected, triggering build"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

  build:
    needs: check
    if: needs.check.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout Iosevka source
        uses: actions/checkout@v4
        with:
          repository: be5invis/Iosevka
          ref: ${{ needs.check.outputs.iosevka_version }}
          path: iosevka-src
          fetch-depth: 1

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ttfautohint python3 python3-pip
          pip install fonttools brotli uharfbuzz

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Copy custom build plan
        run: cp private-build-plans.toml iosevka-src/

      - name: Install dependencies and build
        run: |
          cd iosevka-src
          npm install
          npm run build -- contents::IoskeleyCondensed
          npm run build -- contents::IoskeleyCondensedTerm
          npm run build -- contents::IoskeleyCondensedJBM
          npm run build -- contents::IoskeleyCondensedTermJBM

      - name: Verify build output
        run: |
          for plan in IoskeleyCondensed IoskeleyCondensedTerm IoskeleyCondensedJBM IoskeleyCondensedTermJBM; do
            if [ ! -d "iosevka-src/dist/$plan/TTF" ] || [ ! -d "iosevka-src/dist/$plan/WOFF2" ]; then
              echo "Build output directories for $plan not found!"
              exit 1
            fi
          done
          echo "All build directories verified."

      - name: Download JetBrains Mono
        run: |
          JB_VERSION=$(gh api repos/JetBrains/JetBrainsMono/releases/latest --jq '.tag_name')
          echo "JetBrains Mono version: $JB_VERSION"
          curl -sL "https://github.com/JetBrains/JetBrainsMono/releases/download/${JB_VERSION}/JetBrainsMono-${JB_VERSION#v}.zip" -o jb-mono.zip
          unzip -q jb-mono.zip -d jb-mono
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Patch JBM ligatures into noLigation builds
        run: |
          for plan in IoskeleyCondensedJBM IoskeleyCondensedTermJBM; do
            for ttf in iosevka-src/dist/$plan/TTF/*.ttf iosevka-src/dist/$plan/TTF-Unhinted/*.ttf; do
              suffix=$(basename "$ttf" .ttf | sed "s/^${plan}-//")
              jb_file="jb-mono/fonts/ttf/JetBrainsMono-${suffix}.ttf"
              if [ ! -f "$jb_file" ]; then
                echo "ERROR: No matching JetBrains Mono file for $suffix"
                exit 1
              fi
              echo "Patching $(basename "$ttf") with $(basename "$jb_file")"
              python3 patch-ligatures.py "$ttf" "$jb_file" "$ttf"
            done
          done

      - name: Regenerate WOFF2 for JBM builds
        run: |
          python3 -c "
          import sys, os
          from fontTools.ttLib import TTFont
          for plan in ['IoskeleyCondensedJBM', 'IoskeleyCondensedTermJBM']:
              for subdir, woff_dir in [('TTF', 'WOFF2'), ('TTF-Unhinted', 'WOFF2-Unhinted')]:
                  ttf_path = f'iosevka-src/dist/{plan}/{subdir}'
                  out_path = f'iosevka-src/dist/{plan}/{woff_dir}'
                  os.makedirs(out_path, exist_ok=True)
                  for fname in sorted(os.listdir(ttf_path)):
                      if not fname.endswith('.ttf'):
                          continue
                      src = os.path.join(ttf_path, fname)
                      dst = os.path.join(out_path, fname.replace('.ttf', '.woff2'))
                      print(f'{src} -> {dst}')
                      f = TTFont(src)
                      f.flavor = 'woff2'
                      f.save(dst)
          "

      - name: Smoke test JBM ligatures
        run: |
          TEST_FONT=$(ls iosevka-src/dist/IoskeleyCondensedJBM/TTF/*-Regular.ttf | head -1)
          python3 -c "
          import sys
          import uharfbuzz as hb

          with open(sys.argv[1], 'rb') as f:
              data = f.read()
          face = hb.Face(data)
          font = hb.Font(face)

          def shape(text, features=None):
              buf = hb.Buffer()
              buf.add_str(text)
              buf.guess_segment_properties()
              hb.shape(font, buf, features or {})
              return [i.codepoint for i in buf.glyph_infos]

          failures = []
          for seq in ['=>','->','<-','!=','==','<=','>=','||','&&',
                      '==>','<==','<=>','<==>']:
              on = shape(seq, {'calt': True})
              off = shape(seq, {'calt': False})
              if on == off:
                  failures.append(seq)

          if failures:
              print(f'FAILED ligatures: {failures}')
              sys.exit(1)
          print(f'All tested ligatures verified in {sys.argv[1]}')
          " "$TEST_FONT"

      - name: Normalize file timestamps
        run: |
          find iosevka-src/dist -type f \( -name "*.ttf" -o -name "*.woff2" \) \
            -exec touch -t "$(date +'%Y%m%d')0000.00" {} +

      - name: Package font files
        run: |
          for plan in IoskeleyCondensed IoskeleyCondensedTerm; do
            cd iosevka-src/dist/$plan
            zip -r ../../../${plan}-TTF-Hinted.zip TTF
            zip -r ../../../${plan}-TTF-Unhinted.zip TTF-Unhinted
            zip -r ../../../${plan}-Web.zip WOFF2 WOFF2-Unhinted
            cd ../../..
          done
          for plan in IoskeleyCondensedJBM IoskeleyCondensedTermJBM; do
            # Strip "JBM" from the zip name to match existing naming convention
            base=${plan/JBM/}
            cd iosevka-src/dist/$plan
            zip -r ../../../${base}-JBM-TTF-Hinted.zip TTF
            zip -r ../../../${base}-JBM-TTF-Unhinted.zip TTF-Unhinted
            zip -r ../../../${base}-JBM-Web.zip WOFF2 WOFF2-Unhinted
            cd ../../..
          done

      - name: Create Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IOSEVKA_VERSION: ${{ needs.check.outputs.iosevka_version }}
        run: |
          TAG="iosevka-${IOSEVKA_VERSION}-$(date +'%Y%m%d')-${{ github.run_number }}"
          cat > release-notes.md <<EOF
          Built from [Iosevka ${IOSEVKA_VERSION}](https://github.com/be5invis/Iosevka/releases/tag/${IOSEVKA_VERSION}) with condensed width (500).

          **JBM** variants use JetBrains Mono's full ligature set (~141 ligatures) with a separate font family name, so both variants can be installed side by side.

          **Ioskeley Condensed** (normal spacing — family: "Ioskeley Condensed"):
          - \`IoskeleyCondensed-TTF-Hinted.zip\` — hinted TTF
          - \`IoskeleyCondensed-TTF-Unhinted.zip\` — unhinted TTF
          - \`IoskeleyCondensed-Web.zip\` — WOFF2
          - \`IoskeleyCondensed-JBM-TTF-Hinted.zip\` — hinted TTF + JBM ligatures (family: "Ioskeley Condensed JBM")
          - \`IoskeleyCondensed-JBM-TTF-Unhinted.zip\` — unhinted TTF + JBM ligatures (family: "Ioskeley Condensed JBM")
          - \`IoskeleyCondensed-JBM-Web.zip\` — WOFF2 + JBM ligatures (family: "Ioskeley Condensed JBM")

          **Ioskeley Condensed Term** (term spacing — family: "Ioskeley Condensed Term"):
          - \`IoskeleyCondensedTerm-TTF-Hinted.zip\` — hinted TTF
          - \`IoskeleyCondensedTerm-TTF-Unhinted.zip\` — unhinted TTF
          - \`IoskeleyCondensedTerm-Web.zip\` — WOFF2
          - \`IoskeleyCondensedTerm-JBM-TTF-Hinted.zip\` — hinted TTF + JBM ligatures (family: "Ioskeley Condensed Term JBM")
          - \`IoskeleyCondensedTerm-JBM-TTF-Unhinted.zip\` — unhinted TTF + JBM ligatures (family: "Ioskeley Condensed Term JBM")
          - \`IoskeleyCondensedTerm-JBM-Web.zip\` — WOFF2 + JBM ligatures (family: "Ioskeley Condensed Term JBM")
          EOF
          gh release create "$TAG" \
            --title "Ioskeley Condensed (Iosevka ${IOSEVKA_VERSION})" \
            --notes-file release-notes.md \
            IoskeleyCondensed-TTF-Hinted.zip \
            IoskeleyCondensed-TTF-Unhinted.zip \
            IoskeleyCondensed-Web.zip \
            IoskeleyCondensed-JBM-TTF-Hinted.zip \
            IoskeleyCondensed-JBM-TTF-Unhinted.zip \
            IoskeleyCondensed-JBM-Web.zip \
            IoskeleyCondensedTerm-TTF-Hinted.zip \
            IoskeleyCondensedTerm-TTF-Unhinted.zip \
            IoskeleyCondensedTerm-Web.zip \
            IoskeleyCondensedTerm-JBM-TTF-Hinted.zip \
            IoskeleyCondensedTerm-JBM-TTF-Unhinted.zip \
            IoskeleyCondensedTerm-JBM-Web.zip
